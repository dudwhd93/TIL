# 10장 MySQL의 소스 코드를 추적해 보자

## 10.1 소스 코드를 아는 것이 의미가 있을까?
MySQL은 오픈소스 RDBMS 이다. 그렇기 때문에 누구나 원하는 때에 소스코드를 가지고 빌드된 바이너리를 만들 수 있다.
혹시 개발한 업체가 망해도 누군가가 계속해서 개발해 나가며 기능을 추가할 수 있다 -> 제품의 지속성이 높다
소스코드가 오픈되었고 적절한 라이센스가 존재한다는 것 -> 무료이면서 신뢰성있고 지속성이 있는 제품이다. (오픈소스의 장점이기도 함)

다음과 같은 이유로 MySQL의 소스코드를 읽고 쓰는 기술이 문제 해결에 있어 유용하다
- 장애 발생시 원인을 직접 찾을 수 있다
- 자신이 직접 버그 수정을 할 수 있다
- 자신에게 필요한 기능을 직접 구현할 수 있다.


### 장애가 발생했을 때 원인을 찾을 수 있다
어떤 버그를 수정했는데 MySQL 이 크래쉬되는 경우, 성능에 중요한 문제 발견, 문자가 깨짐 등의 문제가 발생할 때가 있다. 
상용 제품이면 유상 서비스 지원 및 컨설팅을 이용하지만, 오픈소스는 직접 소스코드를 읽어 나가며 문제의 원인을 파악해 볼 수 있다 -> '소스 분석'
소스 분석을 통해 성공적으로 문제의 원인을 파악하면, 그 DB의 해당부분을 사용하는 어플리케이션을 수정하여 에러를 회피할 수 있다.
예를 들어, 특정 SQL 구문이 에러를 일으키는 경우에, 그 구문과 동등하게 동작하는 다른 코드로 바꿔 사용한다.
소스코드를 읽어서 원인을 파악하면 해결방법를 자신있게 실행할 수 있다. (구글링 혹은 메뉴얼만 보고 원인을 파악한 경우에 비해 확실히 자신이 있겠네..)

### 자신이 직접 버그를 수정할 수 있다
문제의 원인이 되는 소스코드의 부분을 알았기 때문에, 그 부분 코드를 수정하면 버그를 고칠 수 있다.

### 자신에게 필요한 기능을 구현할 수 있다
내가 필요한 기능을 코딩을 통해 구현하여 추가할 수 있다.

### MySQL의 소스코드 입수하기
오픈소스이기 때문에 당연히 공개되어 있다. 예를 들어 mysql-5.5.16.tar.gz 파일을 다운받아 압축 해제한다.



## 10.2 소스 코드의 구조를 보자
각 디렉토리에 대해 알아보자.

1. sql 디렉토리
MySQL 본체의 중추 부분이다. 실행파일인 'mysqld' 의 바탕이 되는 파일인 mysqld.cc, 파이너리 로그와 일반 로그의 중추가 되는 log.cc, 복제 관련 소스 등이 포함되어 있다.
스토리지 엔진 등 MySQL 서버 프로그램 빌드에 필요한 '헤더 파일 군'도 여기에 포함되어 있다.
대부분의 경우 '소스 분석' 을 하면 이 디렉토리를 찾아보게 된다.

2. include 디렉토리
각종 헤더 파일이 저장되어 있다. 일반 클라이언트 프로그램 빌드에 필요한 mysql.h 등이 포함되어 있다.

3. storage 디렉토리
MyISAM, InnoDB 등 각 스토리지 엔진의 소스코드가 들어 있는 디텍터리다.
5.1 버전 이후에는 스토리지 엔진은 공유 라이브러리로서 개별적으로 빌드 및 설치가 가능하므로 반드시 본체에 포함되어 있을 필요는 없다.
그러나 MyISAM 과 MEMORY 등 MySQL 동작에 필수적인 엔진들과 InnoDB, ARCHIVE, NDB 와 같이 MySQL 개발사인 Oracle 사가 작성한 엔진은 소스 코드도 MySQL 본체와 함께 배포되고 있다.

4. strings 디렉토리
문자열 처리를 위한 소스파일, 국제화 대응을 위한 파일, 문자 인코딩 매핑 정보 등이 들어있다.
문자 코드 관련 문제에 대해서는 이 디렉토리를 중심으로 살펴본다.

5. mysql-test 디렉토리
MySQL 의 커버리지 테스트 파일들이 저장되어 있다.
회귀 테스트 들이 집약되어 있다.

6. client 디렉토리
MySQL 의 커맨드라인 도구가 될 프로그램들이 들어 있다.
접속 클라이언트인 mysql.cc, 관리 클라이언트인 mysqladmin.cc, dump 용 툴인 mysqldump.c, 바이너리 로그 분석을 위한 mysqlbinlog.cc 등이 포함되어 있다.
MySQL 서버 코드와 독립적이므로 커스토 마이징을 쉽게 할 수 있다.


## 10.3 소스 코드를 분석해보자
행 전체가 수십만 라인이 넘는 소스 코드를 무작정 봐봤자 어쩔 줄 모를 뿐이다.
MySQL과 같은 대규모 소스코드를 읽을 때는 우연을 바라고 분석할 것이 아니라 구체적인 목적을 가지고 분석해야 한다.
필자는 정적 분석과 동적 분석 두가지 방식을 결합하여 분석을 실시한다.

### 정적 분석 방법
grep 과 같은 텍스트 검색 기능을 이용하여 원하는 소스파일과 라인 번호를 찾아 그 주변을 둘러보는 것으로 소스를 이해하는 방법이다.
grep, sed 같은 기초 명령으로 가능하기 때문에 간단하다.
IDE 를 사용하면 호출 함수, 클래스/구조체 의 정의 정보를 왔다 갔다 하면서 볼 수 있고 수많은 기능을 제공해주기 때문에 매우 편해진다.
탐색하려는 키워드가 명확한 경우에 효율이 좋은 작업이다.
- 시스템변수, 상태변수의 거동 추적
- 오류 메시지 검색
    - 에러 로그 파일에 신경쓰이는 메시지가 있는 경우, 그 메시지를 기반으로 MySQL 소스파일을 grep 해본다.
    - ex) MySQL의 상태변수 'Aborted_connects' 값이 시간이 지남에 따라 증가하는 경우 -> 값이 증가하는 원인과 접속을 시도하는 것들 중 어느 것이 무슨 이유로 값을 증가시키는지 알고 싶다

에디터로 파일을 열고 해당 부분의 줄 번호와 그 주변의 처리, 호출원의 함수이름 등을 조사해 나간다.
정적 분석을 통해 엄청나게 많은 양의 소스 코드로부터 조사대상 범위를 제한할 수 있다. 
버그 수정, 신규 개발에도 응용할 수 있다. 때로는 정적 분석 만으로도 문제 원인파악이 충분한 경우가 있다.
하지만 봐야하는 대상 (문제 대상부분 후보) 이 많아질 수록 호출 플로우를 정적 분석만으로 분석하기 어렵다.



### 동적 분석 방법과 MySQL의 빌드 방법
동적 분석이란 MySQL 을 디버깅 하면서 동작을 쫒아감으로써 소스를 이해하는 방법이다.
디버그 기동에는 gdb와 Visual Studio 등을 사용한다.
디버그 기동을 위해서는 사전에 소스코드를 빌드해둬야 한다.
빌드에 시간이 걸리지만 정적분석으로는 알 수 없는 것들을 알게 해준다.

후보가 되는 함수들에 브레이크 포인트를 걸고 처리를 실행한다. (호출플로우를 따라가며 문제원인을 파악해나갈 수 있다)

리눅스 계열 OS에서 오픈소스 SW를 소스코드로부터 설치하기 위해서  1.configure(cmake) 2.make 에 의해 빌드를 실행하고 3.make install 로 설치하는 3단계를 따른다.

#### configure
어떤 스토리지 엔진을 인스톨할 것인가, default char-set 을 무엇으로 할 것인가 등의 환경설정을 한다
그 정의 정보를 바탕으로 컴파일하기위한 Makefile 이 생성된다.
make 로 빌드하고 make install 로 설치한다.
- make -j4
- make install

#### cmake
MySQL 5.5 부터는 configure 대신 cmake 라는 명령어를 사용하게 되었다.
MySQL의 빌드된 바이너리와 동일한 옵션으로 빌드하고 싶을 때 -> 5.5 버전 부터 빌드된 바이너리 cmake 옵션이 docs/INFO_BIN 파일의 끝에 쓰여지게 되었기 때문에 이를 참고하면 된다.

#### make와 make install
MySQL 본체의 빌드는 make에 의해 한다. C 컴파일러는 gcc, C++ 컴파일러로는 g++ 이 사용된다.
make 시에 인수로 '-j <코어 수>' 를 지정하면 병렬로 빌드를 해줘서 빠르다.
make 가 오류없이 끝나면 make install 을 실행한다.

install 후에는 통상대로 mysql_install_db 에 의해 MySQL 의 초기 데이터베이스를 구축한다.

그림 10-6) gdb 에서 MySQL 을 디버깅해 본다 (동적 분석)
1. gdb 로부터 mysqld 실행
$ gdb ./bin/mysqld

2. break point 를 건다
$ (gdb) br sql_connect.cc:919

3. mysql 을 기동한다
$ (gdb) run --defaults-file=/etc/my.cnf

4. 실행을 시켜보면서 문제원인을 파악한다

정적 분석을 통해 문제 범위를 제한한 후, 동적 분석을 통해 자세한 분석을 해나가는 접근 방식이 자주 활용된다.
소스코드에 숙련되면 정적 분석만으로도 문제를 해결할 수 있으며 gdb 를 가볍게 다룰 수 있는 사람이라면 동적 분석도 어렵지 않을 것이다.



## 10.4 MySQL의 설계 사상을 알아보자
설계 사상을 알면 소스 코드를 해석해 나가는데 도움이 된다.

### 플러그인화를 강력히 추진하고 있다
'플러그인 가능한 스토리지 엔진' 에서도 볼 수 있듯이 플러그인화는 MySQL 의 상징 이라고 할만큼 중요한 특징이다.

### 외부 라이브러리에는 최대한 의존하지 않는다
외부 라이브러리에 최대한 독립적으로 제작되었다. C++ 의 STL, boost 같은 핵심 라이브러리들도 사용하지 않는다.
유틸리티들은 MySQL 본체 (주로 mysys)에 가지고 있다.
목적은 품질 일정화와 플랫폼 의존성을 줄이기 위해서 이다.
사용하는 라이브러리에 버그가 있거나 성능의 병목을 일으킨다면 서포트하는 측에서 매우 커다란 일이 된다.
OS 의존 명령은 my_xxx 라는 래퍼 함수에서 제공하고 있다. 예를 들어 mutex lock을 확보하기 위한 함수는 UNIX: pthread_mutex_lock(), WINDOW: EnterCriticalSection() 이렇게 OS 별로 다르다. 
이 차이는 #define 에 의해 매크로로 나뉘어져 있다.

### 디버깅 기능
C/C++ 어플리케이션은 메모리 부정 엑세스에 의한 영역 파괴와 크래쉬, mutex 이중 확보에 의한 교착상태 같은 문제가 발생할 수 있다. 
이와 같은 문제를 최대한 방지하기 위해 디버그판에 대한 malloc/free, pthread_* 같은 일부 함수에 대한 래퍼를 제공하여 이중 잠금이나 부정 엑세스 등이 이뤄질 때 그 자리에서 중단하도록 하고 있다.
릴리즈 전, 개발 단계에서 고칠 수 있으므로 품질향상에 직결된다.

주요 함수가 호출되었을 때 함수이름과 인수 값을 추적하는 기능도 제공하지만 성능 저해 요인이 되므로 릴리즈 판에서는 disable 되어있으며 이에 대한 제어는 매크로로 되어 있다.


### 엔디안 프리
MySQL 에서는 기본적으로 리틀 엔디안 으로 통일된 설계를 하고 있다.
예를 들어, 1 의 2 Byte 표현은 0x100 이다.


### 함수 포인터, 서브 클래스를 많이 사용하여 범용성을 높이기
레코드 읽기 작업의 단계 (흐름)
- 초기 처리하기
- 첫번째 레코드 읽기
- 다음 레코드 읽기 (끝까지 반복)
- 종료 처리하기

1개 레코드 읽기, 범위 검색, 전체 테이블 스캔 인지에 상관없이 동일 흐름으로 진행됨.
스토리지 엔진에 차이가 있어도 흐름에 변화 없음.
-> 재이용성이 높은 코드작성이 가능하고 필요하다.

MySQL 에서는 C++ 가상 함수에 의한 다형성을 구사하고 있다.
C 언어에서는 클래스가 아니지만 함수 포인터를 사용함으로써 유사한 작업을 실현하고 있다.


### 플러그인 개발이란 무엇인가
MySQL 을 해킹하는 데에 크게 2가지 접근 방법이 있다.
- MySQL 본체에 손대기
- MySQL 플러그인 개발하기

#### MySQL 플러그인 개발의 흐름
스토리지 엔진 및 사용자 정의 함수, 통계 DB, 전체 텍스트 검색 기능의 일부, 복제기능의 일부에 있어 본체를 직접 변경하는 대신 플러그인을 개발하여 인스톨하는 방식이 가능하도록 설계되어 있다.
플러그인은 공유 라이브러리 (*.so, *.dll) 로서 INSTALL PLUGIN 은 MySQL 명령으로 설치할 수 있다.
본체를 건드릴 필요가 없기 때문에 표준 바이너리에 인스톨 하는 것도 가능하다.

플러그인 개발용으로서 인터페이스가 공개되어 있어 그 인터페이스 범위 내에서는 원하는대로 구현할 수 있다.
그러나 요구사항에 따라서는 본체의 변화 없이 구현할 수 없는 경우도 있다. 예를 들면 MySQL 본체 소스파일의 static 변수에 엑세스하는 경우, 변수의 scope 가 해당 파일 안이기 때문에 불가하다.

플러그인이 나온 이유
- 대규모 오픈소스 sw 에서는 외부 개발자로부터 패치 포스팅 등 Contribute 가 일어난다
- 포스팅한 패치가 아무리 시간이 지나도 실제 릴리즈 쪽에 반영되지 않는 현상이 많이 발생한다.
- MySQL 도 본체의 변경은 난이도가 커졌다. 패치 도입에 보수적일 수 밖에 없다.
- 플러그인은 본체에 대한 수정 없이도 원하는 기능을 구현하거나 기존 기능을 변경할 수 있다.
- 하지만 플러그인이 커버하는 기능은 전체에서 극히 일부분이기 때문에 본체를 손대어야하는 경우가 많다.


## 10.5 소스 해킹 사례 연구
MySQL 은 소스 코드의 행 수가 수십만 행을 넘기 때문에 갑자기 모든 부분을 탐구하는 것은 무리다. 
어떠한 작업이 무엇을 목적으로한 구현인지를 생각해야 코드에 대한 이해가 쉬워진다.
RDBMS 의 기초 이론들 (SQL문 구분분석, 실행 계획작성, 인덱스로의 엑세스, 트랜잭션 제어 등) 에 대한 이해를 하고나서 코드를 봐야 이해가 빠르다.

하지만 모든 이론을 이해하지 못하더라도 앞으로 나아갈 수 있다. 어느정도 모듈화가 되어있기 때문에 복제 등 자신이 관심가진 포인트를 뽑아서 목적의식을 갖고 소스코드를 읽어나가면 된다.

### 연구사례 1 : 코어 파일에서 문제 부분 특정하기
MySQL이 크래쉬 되었고 오류로그를 봐도 잘 모르겠는 경우, 근본 원인을 알고 싶을 것이다.
my.cnf 에 매개변수 core-file 을 붙여두면 크래쉬 시에 코어 파일이 생성되므로 그것을 gdb 로 읽어들임으로써 어디에서 크래쉬 되었는지를 파악할 수 있다.

크래쉬가 MySQL의 버그로 인해 발생했을 가능성이 큰 경우, 개발자는 다음과 같은 절차를 취한다
1. 버그 원인 파악
2. 버그 수정을 위한 패치 만들기
3. 패치 테스트 수행하기
4. 패치를 본체에 병합하기

#### MySQL의 크래쉬 버그
특정 SQL 문을 실행하면 SQL 이 크래쉬되는 버그가 있었다.
MySQL 이 크래쉬되면 코어 파일이 데이터 디렉터리에 만들어진다. 이 코어파일을 gdb로 읽어들여 백 트레이스를 취득함으로써 어디서 크래쉬를 일으켰는지 소스 코드를 통해 살펴볼 수 있다.

gdb 의 첫번째 파라미터에 크래쉬 시에 실행했던 mysqld 파일, 두번째 파라미터에 코어파일을 지정한다.
gdb 대화 인터페이스에서 bt 라고 입력하면 백 트레이스가 출력된다.

$ gdb ./bin/mysqld data/core.25253
(gdb) bt
백트레이스 내용...
..
..

만약 백트레이스 내용을 봤는데 잘못된 메모리 영역을 참조했을 때 발생하는 Segmentation Fault 가 보인다면 MySQL 본체에 버그가 있을 가능성이 크다고 볼 수 있다.

결국 문제의 원인은 32비트 환경에서는 동작하지만 64비트 환경에서는 제대로 동작하지 않는 코드가 있어서였다. (char* 은 32비트 환경에선 4바이트, 64비트 환경에서는 8바이트인데 고려하지 않고 코딩함)
OS 가 잘못된 메모리 접근을 감지하여 강제 종료해주는 것은 오히려 운이 좋은 경우고 만약 크래쉬없이 영역 파괴를 계속해서 진행할 가능성도 있다. 이런 형태의 버그가 가장 위험한 종류의 버그이다.

#### 패치 만들기
문제를 발견했을 때 패치가 적용되어 새로운 릴리즈가 나올 때까지의 대처로서는 소스코드 상에 문제가 있는 부분을 통과하지 않도록 하는 것이다.
앞선 문제는 bit 타입의 열에 대한 연산에 있어 max_length 가 0인 경우에 문제가 생겼기 때문에, 빈 문자열 대신 NULL 이나 '0' 를 대입하도록 어플리케이션에서 사용하는 쿼리를 수정한다.



### 연구사례 2 : 스택 트레이스로부터 문제 파악하기
어떤 어플리케이션에서 하루에 몇회 정도 모든 세션의 응답시간이 10초 이상 걸리는 현상이 발생하고 있다. 
원인 불명의 성능 손실에 시달리고 있는 경우이다.

슬로우 쿼리 로그를 보면 'begin', 'prepare' 등의 명령에서도 10초 이상 걸리는 케이스가 나오고 있다.
일반적으로 느린 쿼리는 테이블 설계, 인덱스 설계, SQL 문 재검토가 정석이지만, 'begin', 'prepare' 등의 명령은 오래 걸릴 명령이 아니고 테이블에 접근하는 것도 아니기 때문에 최적화할 요소도 없다.

#### 원인규명에 대한 고려
가장 유력한 실마리는 전역적인 mutex를 장시간 가지고 있는 스레드가 있고, 그것이 다른 스레드를 블록하고 있는 패턴이다.
MySQL 에서는 간단한 SQL 문도 실행 과정에서 몇 가지 mutex 의 lock/unlock 을 시행한다. 
mutex 안에는 전역 변수가 되고 있는 것도 있고 짧은 기간 동안만 mutex 를 확보하는 다수의 thread 에 의해 전체 처리량이 떨어질 수도 있다.

그러나 이번 경우는 일반적인 mutex 소요시간의 범위를 벗어난 10초 라는 시간이 걸렸기 떄문에, 글로벌한 mutex 를 확보한 상태에서 어떤 리소스 (네트워크 등 I/O) 에 대한 엑세스를 처리했으나 거기서 무언가 잘못되어 시간을 소비해 버린 결과 모든 스레드가 블록된 것은 아닐까라는 생각이 자연스럽다.

이를 확인하려면 문제가 발생한 시간대의 mysqld 프로세스 내의 모든 스레드 스택 덤프를 취해서 보면 된다. 특정 스레드가 특정 mutex 를 가지고 있는 상태에서 계속 머물러 있다면 그것이 원인이라고 단정할 수 있다.

Linux 에서는 pstack 명령어를 사용하면 프로세스 안의 모든 스레드의 스택 트레이스를 취할 수 있다. 하지만 좀더 자세한 내용을 제공하는 gdb 를 사용하는 편이 낫다.

gdb 에서 모든 스레드의 스택 트레이스를 취하는 쉘 스크립트를 작성하여 확인한다.
5초 간격으로 MySQL 서버에 연결된 소켓 수를 세어 70을 넘으면 이상이 일어났다고 판단하고 스택 추적을 취한다.
gdb 덤프는 gdb 가 프로세스에 연결하고 있는 동안 해당 프로세스의 모든 처리가 멈추기 때문에 신중해야 한다.
기본적으로 자동으로 취득할 것이 아니라 부득이한 경우에 수동으로 취득하는 것이 좋다.


#### 스택 트래이스의 분석
커넥션을 맺고 있는 스레드 거의 전부가 pthread_mutex_lock() 대기 상태로 되어있다. 그리고 2개의 스레드가 pthread_create() 를 통해 clone() 시스템 콜을 하고 있다.
clone() 은 새로운 스레드를 생성하는 콜이다. 스레드 2개가 동일 LWP 번호를 갖고 스택 트레이스가 일치하는 것으로 보아 코드 상 같은 장소에 있는 것이라고 생각할 수 있다.

소스코드를 추적해보면 pthread_create() 에서 호출되는 clone 시스템 콜에서 장시간 걸렸기 때문에 이런 사태가 벌어졌다는 것을 알 수 있다.
왜 clone() 에서 장시간이 걸렸는지는 불행히도 알 수 없었지만, 문제가 되는 소스코드 부분 주변을 적절히 수정함으로써 그래도 조치는 취할 수 있다.


### 연구사례 3 : 새로운 기능 추가해보기
새로운 정렬 알고리즘을 MySQL 본체에 추가하기 사례에 대해 다룬다.
새로운 기능을 추가하기 위해서는 먼저 해당 기능이 왜 필요한가를 정의해야한다.

ORDER BY column1 의 정렬 처리를 수행한 후에 정렬대상 열의 인덱스를 사용할 수 없는 경우, WHERE 조건에 맞는 레코드를 column1 별로 다시 나열하여 그것을 반환해야 한다.
MySQL 에서 이런 정렬 방식이 이뤄질 경우 EXPLAIN 결과 'Using filesort' 라고 출력된다.

MySQL 에서는 정렬해야할 데이터가 세션 변수 sort_buffer_size 에 들어가면 메모리 내에서 퀵정렬을 하고, 없으면 하나이상의 중간 파일을 생성파여 파일간 머지 정렬을 한다.
전체 레코드를 정렬하려면 이 이상 효율화할 수 없기 때문에 어쩔 수 없다.

그러나 만약 'ORDER BY column1 LIMIT 5' 와 같이 반환 건수가 좁혀지면 전체 레코드 정렬을 하는 것 보단 상위 N 개만 정렬하면 된다.
이 요구사항에 맞는 효율적인 알고리즘은 힙 정렬 이다.

이 힙 정렬을 이용한 계산은 기존 MySQL 에는 없는 기능이다. 이 기능을 새로운 기능으로 추가해본다.
기능 추가를 위해 해야할 작업
- MySQL 소스 코드의 어디를 수정해야할지 식별하기
- 어느 조건을 만족시키면 힙 정렬을 할 것인가 결정하기
- 힙 정렬의 처리 구현하기
- EXPLAIN 의 출력으로 힙 정렬이 발생되었다는 것을 나타내기
- 필요에 따라 유틸리티 함수 등을 생성하기
- 올바르게 작동하는지 확인하기 위한 테스트 케이스 작성하기

#### 소스 코드 상의 변경 부분 식별하기
'Using filesort' 라고 나오는 타입의 SQL 문에 대해 퀵정렬 또는 머지 정렬하는 대신 힙정렬을 시킨다는 것이 이번 커스토마이징의 목적이다.
변경해야할 부분이 하나의 함수 내에서 해결된다는 보증이 전혀 없고 이곳 저곳을 변경해야할 수도 있다.
먼저 filesort 를 하고 있는 부분을 찾기 위해 키워드 검색해본다 (정적 분석)
filesort 함수 부분을 찾고 디버그 빌드하여 디버거를 통해 함수내부 로직을 파악한다.

#### 어떤 조건을 만족하면 힙 정렬을 할 것 인지 결정한다
filesort 함수의 동작이 어느 정도 이해되었다면 힙 정렬을 위한 조건을 결정하도록 한다.
LIMIT 절을 사용하고 대상 건수가 충분히 작은 경우가 타겟이다.
- (한 레코드당 정렬 대상 열의 길이 X LIMIT 대상 레코드 수) 가 정렬 버퍼 크기보다 충분히 작을 때
- 전체 레코드 수가 LIMIT 대상 레코드 수보다도 충분히 클 때

filesort 함수 내부를 조사하여 이러한 조건을 어디에 끼워넣을 수 있을지 고민해본다.

#### 힙 정렬 구현하기
MySQL 의 filesort 에는 퀵정렬과 머지정렬 두 종류가 있지만, 내부적으로는 더 세분화된 2 종류의 알고리즘으로 나뉘어 있다.
그것은 정렬 대상이 아닌 열을 어떻게 하는가 이다.
예를 들어, 'SELECT c1,c2,c3 ORDER BY c4' 라는 쿼리가 있을 때, 마지막에 보여주는건 c1-c4 지만 정렬해야할 열은 c4 뿐이다.
MySQL 은 이런 경우 2가지 중 하나의 알고리즘으로 정렬한다.
1. c4 열의 레코드와 레코드의 위치를 나타내는 포인터를 정렬 버퍼로 읽어들여 정렬하고 레코드 포인터에 남아있는 열 c1-c3 를 읽어 반환한다.
2. c1-c4의 모든 열을 정렬 버퍼에 읽어들여 정렬을 한다. 그 후 정렬 버퍼의 내용을 반환한다.

1은 2에 비해 정렬 범위가 좁아져 재정렬 효율은 향상되지만 c4 열을 읽는 처리와 나머지 열을 읽는 처리 등 2차례에 걸쳐 데이터 파일에 엑세스 해야한다.
2에서는 데이터 파일로의 엑세스는 1번 이뤄진다. 따라서 전체 레코드 정렬의 경우에는 2번이 효율적이고 MySQL 에서는 기본적으로 2번을 선택한다.

힙정렬을 하는 경우는 반환 대상 열이 몇개 안되므로 1번을 선택한다.
MySQL 소스코드 안에서 1,2 판정 처리하는 부분을 찾아 힙 정렬을 하는 경우 1을 선택하도록 한다. 이러한 판정처리도 filesort() 함수 안에서 한다.

filesort 함수 안의 코드를 적절히 수정하여 정렬 방식을 결정하는 처리에 따라 힙 정렬 기능이 잘 동작하도록 한다.
물론 힙 정렬을 처리하는 코드도 구현해야한다.

#### EXPLAIN 의 결과 출력 제어하기
정말 힙 정렬을 하고 있는지 여부 확인을 위해 EXPLAIN 출력으로 'Using filesort' 라고 나오던 것을 힙 정렬이 선택되면 그것이라고 알 수 있는 메시지로 바꾸어 보자.
힙 정렬이 발생할 가능성이 있는지 여부를 판정하는 과정을 넣어 조건을 충족하면 'Using filesort' 대신 'Using top-N in memory sort' 라고 표시하자.

#### 테스트 케이스 작성하기
소스코드를 수정하면 우선 빌드를 다시 하여 제대로 빌드되는지 확인한다. 힙정렬이 발생할 쿼리를 실행하여 결과를 확인한다.
MySQL 에서는 회귀테스트를 위해 mysql-test 라는 test-suit 을 준비하고 있다.
- 테스트용 SQL 문 파일
- 예상 결과 파일

#### 패치의 실행 예
힙 정렬이 실제로 시행되었는지를 확인하고 성능을 분석한다.
전체 정렬 대상 row 수가 많고 LIMIT 대상 수는 적을 때 탁월한 성능향상을 보여준다.




## 10.6 MySQL 개발 커뮤니티

### 버그 리포트
http://bugs.mysql.com 에서 MySQL에 관한 버그를 접수받고 있다.
발생한 문제, 개요, 재현 순서, 어떻게 수정해야 하는가 항목을 가지고 있다.
MySQL 개발자가 내용을 확인하여 버그가 재현되는 경우 복구 방법 검토에 들어간다.
자력으로 수정 패치까지 제작한 경우 어필을 위해서라도 첨부파일로 제출한다.

### WorkLog 로 새로운 기능을 등록
WorkLog 는 MySQL 의 신기능 개발 계획을 관리하는 웹 페이지이다.
여기에 새로운 기능을 등록함으로써 그 기능이 어떤 기술영역에 속하는가에 따라 개발팀 안에 담당자가 할당되고 설계 검토와 코드 검토 등을 실시해나간다.

### 패치 게시/리뷰/토론
자신이 작성한 패치는 전 세계 사용자들에게 공개된다.
공개 플로우는 WorkLog 및 커밋 메일용의 메일링 리스트를 통해 한다.
패치 작성자가 메일링 리스트에 게시하면 담당자가 리뷰결과를 반환하고 그에 대한 논의가 계속 되어진다.
서로 간의 모든 연락은 기본적으로 모두 공개된다.

#### 패치 리뷰
설계 리뷰 후에 패치 리뷰가 이뤄진다. 코딩 규약 준수, 충분한 테스트 코드 여부 등을 확인한다.
기타 MySQL 내부 구조 등 깊은 주제에 대한 논의는 메일링 리스트에서 이뤄지고 있다.


