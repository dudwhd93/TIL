# 11장. 데이터베이스 기술의 현재와 미래

## 11.4 NoSQL 데이터베이스

### 메모리 안에서의 처리가 낳은 새로운 과제
기존에는 CPU, 메모리 상에서 처리를 완료하는 시간은 마이크로세컨드, 디스크 I/O를 처리하는 시간은 밀리세컨드 단위가 걸렸기 때문에 전자는 무시할 수 있는 수준이었다.
데이터베이시의 속도, 성능이라 함은 디스크 I/O 를 처리하는 시간에 달렸었다.
이 디스크 I/O 오버헤드가 상대적으로 0에 가깝게 되면 새로운 병목현상으로 CPU, 메모리 상에서의 처리가 부상할 수 있다.
데이터가 메모리 안에 있을 수 있으면 읽기 처리가 모두 메모리 안에서 이뤄지는 것으므로 초당 처리할 수 있는 쿼리수가 극적으로 증가한다.

서버에 탑재가능한 메모리 사이즈가 늘어나면서 모든 데이터를 메모리에 넣을 수 있게 되었다.
예를 들어, 사용자 ID를 기본 키로 한 테이블에서는 레코드 수는 그 서비스의 사용자 수와 동일하다.
사용자가 1억 명이고, 레코드 당 크기는 100 바이트라고 하면 10GB 크기밖에 안된다. 16GB 메모리를 탑재한 서버에서 메모리안에서 충분히 처리가능하다.
이렇게 메모리 탑재량이 늘면서 메모리 내에서 처리를 완료하는 유형의 데이터처리가 많아 지고 있다. 한편 기존 SQL 데이터베이스는 메모리 내에서 처리하는데 낭비가 크다는 문제가 있다.


### SQL 데이터베이스의 과제 
위 예에서 등장한 사용자테이블은 대부분 작업이 사용자 ID의 기본키 검색이 된다는 점이다.
- SELECT ... FROM user WHERE user_id = ?
이러한 검색 쿼리가 ? 값만 바뀌며 반복이 된다.

SQL 문을 실행할 때 아래와 같은 과정을 거친다.
1. 쿼리의 수신
2. 구문 해석
3. 테이블의 오픈
4. 테이블 잠금
5. 실행 계획의 작성
6. 레코드로의 엑세스
7. 테이블의 잠금 해제
8. 테이블의 클로즈
9. 결과 회신

대부분의 과정이 반복되게 된다. 또한 실제로 어플리케이션에 있어 의미있는 작업은 1,6,9 뿐이다. 그외에는 모두 불필요한 처리일 뿐이다.
그러나 이러한 불필요한 처리가 성능의 병목인 경우가 많다. 구문 분석 및 테이블 여닫기 과정과 그 과정에서 발생하는 스레드 사이의 경쟁으로 인해 병목이 발생한다.
이러한 문제점들은 모두 SQL 데이터베이스가 가진 과제이다.


### NoSQL 이란 무엇인가
앞서 SQL 문의 처리 자체가 비용이 의외로 높다는 것을 알았다.
기본키 검색과 같은 단순한 엑세스 패턴은 SQL 문과 같은 복잡한 언어를 사용하지 않고 프로그래밍 언어의 라이브러리 함수를 사용하여 직접 데이터를 엑세스하는게 훨씬 고속으로 되는게 아닌가 라는 의문을 가져왔다.
그런 배경에서 NoSQL이 나왔고, NoSQL은 SQL 문이 아니라 간단한 명령으로 처리를 주고받는다.
- memcached 의 'get key1 4'

NoSQL 을 사용함으로써 네트워크 송수신 전송량이 감소하고 구문 분석을 위한 비용도 감소한다. 따라서 CPU 사용량을 줄일 수 있다.

### NoSQL 은 테이블/파일을 연 채로 놔둔다.
SQL DB 에서는 레코드에 접근하기 위해 해당 테이블을 미리 열어놔야 한다. 또한 레코드 접근을 위해 매번 테이블 열기/닫기 비용이 발생된다.
테이블을 누가 열었는지 관리해야 하며 누군가가 테이블을 연 상태에서 다른 사용자가 테이블을 삭제하거나 정의 변경 못하도록 배타 제어를 해야한다.
따라서 SQL 을 실행할 떄는 엑세스 대상 테이블에 대해 테이블을 열고 실행을 마친 후 테이블을 클로즈하는 작업이 발생한다.
웹 어플리케이션에서는 많은 클라이언트가 일제히 동일 테이블에 엑세스가 쇄도하는 경우가 있는데 이런 경우에는 테이블에 대한 경합이 발생한다.

NoSQL은 미리 테이블을 열어둔 채로 개별 SQL 문의 처리에서는 테이블의 열기, 닫기를 생략하고 있다. 비용이 발생하지 않고 성능향상이 된다.



### 일반적인 NoSQL의 단점

NoSQL 에 의해 계산량의 격감과 경쟁 소멸을 실현하여 메모리 안에서의 기본키 검색이 압도적으로 빨라졌다.
NoSQL은 RDBMS 에서는 지원하는 기능을 갖고 이지 않기도 하므로 주의를 하여 사용해야한다.

#### 트랜잭션을 지원하지 않는다
실패한 작업을 없던 일로 하는 것을 자동으로 처리해주지 못한다.
쓰기 도중 크래쉬 발생시 어중간한 데이터를 없던 일로 하는 것도 못하고 마지막 커밋한 데이터까지의 무사함을 보장할 수도 없다.
즉, 없어도 별로 상관없는 데이터에만 사용할 수 있다.

#### 스키마가 없다
RDBMS 에서는 각 데이터 항목에 대해 열 이름, 데이터형, 값 제약조건을 설정할 수 있고 테이블 간 연결도 가능하다.
사용자 입장에서 보면 테이블 정의만 보면 어떤 종류이 데이터가 들어있을지 예측할 수 있다.

이에 비해 NoSQL은 키에 대한하는 값을 가진 것이 대부분이다. 값에는 임의의 바이트 열을 넣을 수 있고 무엇이 들어가있는지는 조회해봐야안다.
값의 체크는 어플리케이션에서 해야한다.
어떤 데이터가 들어있는지 NoSQL 에서는 잘 알 수가 없는데, 이는 유지보수 측면에서 어려움을 가져올 수 있다.

#### 기본 키 이외의 인덱스를 사용할 수 없다
기본키 이외의 조건에서 빠르게 검색하기 위해서 기본키가 아닌 열에 대해 인덱스를 부여해야한다.
NoSQL 에서는 키/값 의 두가지 항목밖에 갖지 않는다는 특성상 기본키 이외의 인덱스를 취할 수 없다.
이걸 지원하는 NoSQL 들도 있지만, 트랜잭션이나 병렬성 등에서 RDBMS 상당의 수준까지의 세련된 수준인지 충분한 검증이 필요하다.



### NoSQL 의 용도
'사라져도 별로 상관없는 데이터'가 꽤 있다.

#### 캐시
가장 많이 사용되는 NoSQL의 용도는 RDBMS 의 캐시로 사용되는 것이다.
이러한 용도로 정평이 나있는 제품이 memcached 이다.

#### 세션 데이터
예를 들어 SNS 특정 계정의 '최종 엑세스 시간' 관리에 사용될 수 있다.
이 경우에는 갱신 트래픽과 참조 트래픽이 매우 좋다.
또한 이 정보는 다소 정확성이 떨어져도 큰 문제가 되지 않는다. 검색 키도 사용자 ID 외에 다른 것이 필요하지 않다.
이런 경우, 기능과 무정지성을 다소 희생하고 성능쪽을 추구하려는 목적으로 NoSQL 을 사용한다.

### RDBMS와 NoSQL의 하이브리드 구성
RDBMS는 NoSQL에 비해 기능이 풍부한 대신 SQL 문을 사용하여 엑세스해야하며 오버헤드가 크고 성능을 낼 수 없다.
개발자들은 어떻게 하면 RDBMS 를 개선하여 NoSQL과 같은 성능을 낼 것인가를 고민해왔다.
MySQL Cluster (NDB) 는 어떤 때에는 RDBMS 로 사용하고, 어떤 때에는 NoSQL 로 사용할 수 있는 제품이다.

#### MySQL Cluster (NDB)
MySQL 스토리지 엔진 중 하나로, SQL 문을 사용하여 데이터에 엑세스할 수 있다.
NDBAPI 라는 C++ API 를 사용하여 백엔드 스토리지에 직접 엑세스하는 방법을 제공한다. 일반적인 처리는 SQL 문으로 실행하고 빠른 성능을 필요로 하는 작업에는 NDBAPI 를 사용한다.
트랜잭션을 지원하고 테이블 정의도 가능하다.


#### myCached/HandlerSocket 
MySQL Cluster의 가장 큰 단점은 MySQL NDB 스토리지 엔진에서만 사용할 수 있다 라는 점이다.
대부분의 MySQL 사용자들은 InnoDB 라는 스토리지 엔진을 사용중이기 때문에 NDB 스토리지 엔진의 혜택을 받을 수 없다.
또한 NDB는 메모리의 성능에 최적화된 데이터베이스라서 실제 데이터 크기가 메모리 크기를 초과하는 경우에는 단점이 많아 사용하기 어려운 측면이 있다.
스토리지 엔진은 InnoDB를 사용하며 NoSQL의 성능을 낼 수 없는가 라는 요구사항이 생겨났다.
이런 요구사항을 만족시키기위해 개발된 게 myCached 라는 제품이다.
MySQL 서버에서 실행되는 데몬 프로그램으로 memcached 프로토콜로 통신하면 myCached 가 그걸 해석해서 스토리지엔진으로 스토리지엔진 API 를 사용하여 데이터에 엑세스한다.
myCached 는 포로토타입 제품이었고, 사용제품은 HandlerSocket 이었다.
HandlerSocket 은 MySQL 플러그인으로 동작한다. SQL 문으로 엑세스하려는 경우에는 기존대로 MySQL 프로토콜로 엑세스 한다.
반면에 빠르게 엑세스하려는 경우에는 전용 프로토콜을 사용하여 엑세스 한다. 전용 프로토콜을 구현한 클라이언트가 필요하다.

유저 테이블에는 유저정보 취득처리가 매우 빈번히 발생한다. 유저테이블에 많은 속성정보를 가지고 있기 때문에 열의 수가 많은 경우 MySQL 통신 패킷에는 열의 이름과 같은 메타정보가 포함되므로 패킷 크기가 커진다.
이때 HandlerSocket을 사용하면, CPU 사용량과 네트워크 부하를 크게 감소시킬 수 있다.


#### 분산 데이터베이스
NoSQL이 주목받는 이유는 성능말고도 분산 데이터베이스로 사용될 수 있기 때문이다.
서버 한대로 충분히 트래픽을 처리할 수 없는 경우 서버를 추가하면 자동으로 데이터 분산배치, 분산 처리를 해주는 NoSQL 제품들이 많다.
이것을 나타내는 키워드로 'Write Scaling' 이라는 용어가 사용된다.
읽기 작업이 대량으로 발생하는 경우는 슬레이브를 대량 추가거나 캐시서버를 늘리면 되나 쓰기작업 폭발은 쓰기 처리를 여러 서버로 분산시키는 방법밖에 없다.
이 때는 분산되어있는 데이터를 잘 관리하기 위해 서버끼리 협동을 잘 하는게 중요하다.



## 11.5 그 외의 주제

### Write Once 의 데이터베이스
트랜잭션에 대한 데이터베이스 아키텍처는 커밋시에 REDO 로그 파일에 기록하고 그 후에 데이터 파일 (데이터 영역과 인덱스 영역) 에 기록하는 구조로 되어 있다.
2번 기록하는 이유는 HDD 와 같은 디스크에서는 시퀀셜 라이트가 랜덤 엑세스 보다 압도적으로 빠르기 때문이다. REDO 로그 파일로의 쓰기는 시퀀셜 라이트이며 데이터 파일로의 쓰기는 랜덤 엑세스 이다.
커밋시마다 랜덤 엑세스 하게 되면 성능이 안나오지만 REDO 로그 파일로의 엑세스 를 통해 성능좋은 커밋이 가능하다.

한편, SSD의 등장으로 랜덤 엑세스 성능이 높아지면서 2회쓰기의 오버헤드에 대한 의문이 들기 시작했다.
이에 1회 쓰기로 커밋처리를 완료하는 데이터베이스의 구현도 진행되고 있다.


### Write Scaling

참조 처리와 달리 쓰기 성능을 높이는 것은 쉽지 않다.
Write Scaling 을 통해 쓰기 성능을 높일 수 있다.

#### 다중 마스터 구성
1개 마스터 여러 개의 슬레이브가 연결되어 항상 1개의 마스터에서만 업데이트하는 것이 일반적 복제 구성이다.
여러 마스터에서 각각 업데이트 트래픽을 받고 그것을 다른 서버에 복제하는 기술도 있다. 이것이 다중 마스터 구성이다.

다중 마스터 구성을 해도 결국 한 대당 업데이트하는 쿼리 수는 변하지 않는다. 하지만 전 세계로 전개하는 서비스 라면 가까운 마스터에 업데이트하는 정책을 가져감으로써 네트워크 효율성을 높일 수 있다.
도쿄 사용자는 도쿄의 마스터로 업데이트하고 미국 사용자는 미국 마스터를 업데이트하면 업데이트에 걸리는 네트워크 지연을 줄일 수 있다.

다중 마스터 구성의 문제중 하나는 갱신 충돌을 어떻게 감지할 것인가 이다. 동일한 기본 키에 동시에 다른 마스터에서 업데이트 된다면 통일을 위해 어떻게 처리해야할까?
이러한 충돌을 감지하여 하나로 통일하는 구조, 정책이 필요하다.

#### 자동 Shard 편성
데이터마다 복수의 서버로 분산하여 한 대당 데이터 처리량을 줄이고 갱신 처리도 분산시키는 '수평분할 (sharding)' 이 자주 사용된다.
sharding 구성을 취하기 위해 기본적으로 어플리케이션에서 '어떤 ID가 어느 shard 로 가는가'라는 매핑 정보를 관리할 필요가 있다.
이런 로직이 잘 되어있다면 스케일을 확장하기 쉬운 서비스를 구축할 수 있다.

하지만 원래 2개의 shard 가 있었는데 shard 를 하나 더 추가하고 싶을 때, 데이터를 이동하는 것이 힘들어진다.
이러한 shard 추가 재배치를 완전히 자동화하는 유형이 DB 도 나오고 있다. MySQL 이라면 MySQL Cluster, NoSQL 세계에서는 MongoDB 나 HBase 등이 이러한 shard 추가 및 재배치에 대응하고 있다.
안정성이 아직 매우 높지는 않지만, 꾸준히 앞으로도 입지를 다져 나갈 것이다.





